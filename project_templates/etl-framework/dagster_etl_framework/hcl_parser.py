"""
HCL Parser for Atlas-generated schema files.

Parses HCL schema files generated by Atlas (dbci-tools) to extract
table and column definitions for validation against ETL source models.
"""

import re
from pathlib import Path
from dataclasses import dataclass
from typing import Dict, List, Optional


@dataclass
class HclColumn:
    """Represents a column in an HCL table definition."""
    name: str
    type: str
    null: bool
    default: Optional[str] = None


@dataclass
class HclTable:
    """Represents a table in an HCL schema."""
    name: str
    schema: str
    columns: Dict[str, HclColumn]
    primary_key: List[str]
    indexes: Dict[str, List[str]]


class HclParser:
    """Parser for Atlas HCL schema files."""
    
    def __init__(self, hcl_file: Path):
        """
        Initialize HCL parser.
        
        Args:
            hcl_file: Path to the HCL schema file
        """
        self.hcl_file = hcl_file
        self.tables: Dict[str, HclTable] = {}
        
    def parse(self) -> Dict[str, HclTable]:
        """
        Parse the HCL file and extract table definitions.
        
        Returns:
            Dictionary of table name to HclTable
        """
        if not self.hcl_file.exists():
            raise FileNotFoundError(f"HCL file not found: {self.hcl_file}")
        
        content = self.hcl_file.read_text(encoding='utf-8')
        self._parse_tables(content)
        return self.tables
    
    def _parse_tables(self, content: str):
        """Parse all table definitions from HCL content."""
        # Find all table blocks by manually tracking braces
        i = 0
        while i < len(content):
            # Look for table declaration
            table_match = re.match(r'table\s+"([^"]+)"\s+\{', content[i:])
            if table_match:
                table_name = table_match.group(1)
                start = i + table_match.end()
                
                # Find the matching closing brace
                brace_count = 1
                j = start
                while j < len(content) and brace_count > 0:
                    if content[j] == '{':
                        brace_count += 1
                    elif content[j] == '}':
                        brace_count -= 1
                    j += 1
                
                if brace_count == 0:
                    table_body = content[start:j-1]
                    
                    # Only parse dimension and fact tables
                    if table_name.startswith('t_dim_') or table_name.startswith('t_fact_'):
                        table = self._parse_table(table_name, table_body)
                        self.tables[table_name] = table
                    
                    i = j
                else:
                    i += 1
            else:
                i += 1
    
    def _parse_table(self, table_name: str, table_body: str) -> HclTable:
        """Parse a single table definition."""
        columns = {}
        primary_key = []
        indexes = {}
        schema = "public"
        
        # Extract schema
        schema_match = re.search(r'schema\s+=\s+schema\.(\w+)', table_body)
        if schema_match:
            schema = schema_match.group(1)
        
        # Extract columns
        column_pattern = r'column\s+"([^"]+)"\s+\{([^}]+)\}'
        for col_match in re.finditer(column_pattern, table_body, re.DOTALL):
            col_name = col_match.group(1)
            col_body = col_match.group(2)
            column = self._parse_column(col_name, col_body)
            columns[col_name] = column
        
        # Extract primary key
        pk_match = re.search(r'primary_key\s+\{[^}]*columns\s+=\s+\[([^\]]+)\]', table_body, re.DOTALL)
        if pk_match:
            pk_cols = pk_match.group(1)
            # Extract column names from column.xxx references
            primary_key = [m.group(1) for m in re.finditer(r'column\.(\w+)', pk_cols)]
        
        # Extract indexes
        index_pattern = r'index\s+"([^"]+)"\s+\{[^}]*columns\s+=\s+\[([^\]]+)\]'
        for idx_match in re.finditer(index_pattern, table_body, re.DOTALL):
            idx_name = idx_match.group(1)
            idx_cols = idx_match.group(2)
            # Extract column names from column.xxx references
            indexes[idx_name] = [m.group(1) for m in re.finditer(r'column\.(\w+)', idx_cols)]
        
        return HclTable(
            name=table_name,
            schema=schema,
            columns=columns,
            primary_key=primary_key,
            indexes=indexes
        )
    
    def _parse_column(self, col_name: str, col_body: str) -> HclColumn:
        """Parse a single column definition."""
        # Extract type
        type_match = re.search(r'type\s+=\s+(\w+(?:\([^)]+\))?)', col_body)
        col_type = type_match.group(1) if type_match else "unknown"
        
        # Extract null constraint
        null_match = re.search(r'null\s+=\s+(true|false)', col_body)
        nullable = null_match.group(1) == 'true' if null_match else True
        
        # Extract default value
        default_match = re.search(r'default\s+=\s+(.+)', col_body)
        default_value = default_match.group(1).strip() if default_match else None
        
        return HclColumn(
            name=col_name,
            type=col_type,
            null=nullable,
            default=default_value
        )
    
    def get_dim_tables(self) -> Dict[str, HclTable]:
        """Get all dimension tables (t_dim_*)."""
        return {name: table for name, table in self.tables.items() 
                if name.startswith('t_dim_')}
    
    def get_fact_tables(self) -> Dict[str, HclTable]:
        """Get all fact tables (t_fact_*)."""
        return {name: table for name, table in self.tables.items() 
                if name.startswith('t_fact_')}
